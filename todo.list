recursive value 即 var a=xxx,如果在推导a的类型的时候又出现了对a的使用，则表示这是一个recursive value,拒绝执行
函数有个标志表示是否需要this

第零遍扫描把所有的class定义转换成user_type
第一遍扫描得到基础类型，本次以后的扫描遇到模板声明，把所有的模板类型<T>注册为用户自定义类型，结束作用域后删除，需要给lexer增加移除功能
第二遍得到推导类型
第三遍扫描闭包捕获
第四遍得到语法树(可以得到非泛型的语法错误)

然后交给后端，后端检测所有的泛型实例化，能正确生成则生成代码，否则报错
这样就能在编译期间报出所有错误

在使用反射实例化泛型的时候(使用runtime的magic)，如果实例化失败,由runtime抛出异常


var abc:int;
class A extends int{
    var abc:int;
    var a=b;
    var b=c;
    var c=d+e;
    var d=fun1();
    var e=fun2();
}
//对于自动类型，采用链式推导

var a:Set<int>;
var b:int=1;
val c:int[][][][];
val d:Map<int,int>[][][]=1;
function e<T1,T2>(a:Set<Map<int,int>>,b:int):int{

};
class Set<V>{
    function getVal():V{
        return new V();
    }
}
class Map<K,V>{

}
class myClass<T1,T2> extends int{
    function a():int{
        
    };
    function b(){
        
    };
}
class myClass{
    
}